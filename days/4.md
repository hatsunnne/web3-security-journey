# day 04 — solidity syntax

**date:** february 18, 2026
**course:** [Cyfrin Updraft — Solidity Fundamentals](https://updraft.cyfrin.io/)

---

## what i did today

spent the rest of the day deep in solidity syntax. it is starting to click. by the end i wrote a small bank contract from scratch just to put everything together — and it actually worked.

---

## the basics

every solidity file starts with two things:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;
```

the license identifier is just a comment telling people how they can use your code. the pragma line tells the compiler which version of solidity to use. the `^` means "this version or anything compatible above it".

---

## contract

everything lives inside a `contract`. think of it like a class in other languages.

```solidity
contract Bank {
    // all your state and logic goes here
}
```

---

## variables and types

solidity is statically typed. you have to declare the type of every variable.

- `uint256` — unsigned integer (no negatives). used for balances, amounts, counts.
- `address` — an ethereum address. 20 bytes. every wallet and contract has one.
- `bool` — true or false.
- `string` — text.

---

## struct

a struct lets you group related data together into a custom type.

```solidity
struct Account {
    address owner;
    uint256 balance;
}
```

here i am defining what an account looks like — it has an owner address and a balance.

---

## mapping

a mapping is like a dictionary or hashmap. it maps one type to another.

```solidity
mapping(address => Account) private accounts;
```

this maps every address to its Account. when a user interacts with the contract, i can look up their account instantly with `accounts[msg.sender]`.

---

## msg.sender

`msg.sender` is a global variable that always holds the address of whoever called the current function. it is how contracts know who they are talking to.

---

## functions

```solidity
function deposit() public payable {
    require(accounts[msg.sender].owner != address(0), "nao existe");
    accounts[msg.sender].balance += msg.value;
}
```

- `public` — anyone can call this function.
- `payable` — this function can receive ETH. `msg.value` holds how much was sent.
- `view` — used on functions that only read state, never write. costs no gas when called externally.

---

## require

```solidity
require(accounts[msg.sender].balance >= amount, "sem dinheiro");
```

`require` checks a condition. if it is false, the whole transaction reverts and nothing changes. this is the main way to validate input and guard functions.

---

## the bank contract i wrote

putting it all together — a simple bank where users can create accounts, deposit, withdraw, and check their balance.

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract Bank {

    struct Account {
        address owner;
        uint256 balance;
    }

    mapping(address => Account) private accounts;

    function createAccount() public {
        require(accounts[msg.sender].owner == address(0), "ja existe");
        accounts[msg.sender] = Account(msg.sender, 0);
    }

    function deposit() public payable {
        require(accounts[msg.sender].owner != address(0), "nao existe");
        accounts[msg.sender].balance += msg.value;
    }

    function withdraw(uint256 amount) public {
        require(accounts[msg.sender].owner != address(0), "nao existe");
        require(accounts[msg.sender].balance >= amount, "sem dinheiro");
        accounts[msg.sender].balance -= amount;
        payable(msg.sender).transfer(amount);
    }

    function getBalance() public view returns (uint256) {
        require(accounts[msg.sender].owner != address(0), "nao existe");
        return accounts[msg.sender].balance;
    }

    receive() external payable {
        deposit();
    }
}
```

`receive()` is a special function that runs automatically when someone sends ETH directly to the contract address without calling any function. here i just redirect it to `deposit()`.

---

## what i already noticed about security

writing this contract i already spotted something interesting — the `withdraw` function updates the balance before transferring. that order matters a lot. if it were the other way around (transfer first, then update balance), a malicious contract could call back into `withdraw` before the balance is updated and drain funds. that attack is called reentrancy. i will study it properly soon.

---

## overall feeling

writing actual code makes everything more concrete. solidity is not that hard to read — the dangerous part is all the implicit behavior you have to know about. `msg.value`, ETH transfers, the order of operations — tiny details that can cost everything.

**tomorrow:** going deeper into solidity — events, inheritance, interfaces.
